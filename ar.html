<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>ë‹¬ê³ ë‚˜ AR í•„í„° - ë””ë²„ê·¸ ë²„ì „</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <style>
    * { box-sizing: border-box; }
    html, body { 
      margin: 0; 
      padding: 0;
      height: 100%; 
      background: #000; 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
      touch-action: manipulation;
    }
    
    #ar-container { 
      position: fixed; 
      inset: 0; 
      z-index: 1;
    }
    
    #ui { 
      position: fixed; 
      inset: 0; 
      display: flex; 
      flex-direction: column;
      align-items: center; 
      justify-content: center; 
      background: rgba(0,0,0,0.9);
      z-index: 100;
    }
    
    #start {
      padding: 16px 32px; 
      font-size: 18px; 
      border-radius: 50px; 
      border: 2px solid #667eea;
      background: #667eea;
      color: white; 
      font-weight: 700; 
      cursor: pointer;
      transition: all 0.3s ease;
      min-width: 200px;
    }
    
    #start:hover {
      background: #5a67d8;
      border-color: #5a67d8;
    }
    
    #start:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    
    #debug {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.8);
      color: #00ff00;
      padding: 10px;
      font-family: monospace;
      font-size: 12px;
      border-radius: 5px;
      max-width: 300px;
      z-index: 200;
      white-space: pre-wrap;
      max-height: 200px;
      overflow-y: auto;
    }
    
    #status {
      color: white;
      margin-top: 20px;
      text-align: center;
      padding: 0 20px;
    }
    
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      border-top-color: #667eea;
      animation: spin 1s ease-in-out infinite;
      margin: 20px auto;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    #video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 10;
    }

    #controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 50;
      display: none;
      gap: 10px;
    }

    .control-btn {
      background: rgba(255,255,255,0.2);
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
      padding: 12px 20px;
      border-radius: 25px;
      cursor: pointer;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
      font-size: 14px;
    }

    .control-btn:hover {
      background: rgba(255,255,255,0.3);
    }
  </style>
</head>
<body>
  <!-- ë””ë²„ê·¸ ì •ë³´ -->
  <div id="debug"></div>

  <!-- UI ë ˆì´ì–´ -->
  <div id="ui">
    <button id="start">ğŸª ë‹¬ê³ ë‚˜ í•„í„° ì‹œì‘</button>
    <div id="status">ì¹´ë©”ë¼ ê¶Œí•œì„ í—ˆìš©í•˜ê³  ë‹¬ê³ ë‚˜ë¥¼ ì–¼êµ´ì— ì˜¬ë ¤ë³´ì„¸ìš”!</div>
  </div>

  <!-- ì»¨íŠ¸ë¡¤ ë²„íŠ¼ë“¤ -->
  <div id="controls">
    <button class="control-btn" id="toggle-filter">ë‹¬ê³ ë‚˜ ëª¨ì–‘ ë³€ê²½</button>
    <button class="control-btn" id="switch-camera">ì¹´ë©”ë¼ ì „í™˜</button>
    <button class="control-btn" id="bite-effect">í•œ ì… ë² ì–´ë¨¹ê¸°</button>
  </div>

  <!-- AR ì»¨í…Œì´ë„ˆ -->
  <div id="ar-container"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    // ë””ë²„ê·¸ ë¡œê·¸ í•¨ìˆ˜
    function debugLog(message) {
      console.log(message);
      const debugEl = document.getElementById('debug');
      const timestamp = new Date().toLocaleTimeString();
      debugEl.textContent += `[${timestamp}] ${message}\n`;
      debugEl.scrollTop = debugEl.scrollHeight;
    }

    // ìƒíƒœ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
    function updateStatus(message) {
      document.getElementById('status').textContent = message;
      debugLog(`STATUS: ${message}`);
    }

    class SimpleARFilter {
      constructor() {
        this.video = null;
        this.canvas = null;
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.filterGroup = null;
        this.isRunning = false;
        this.currentFilter = 0;
        this.facingMode = 'user';
        
        debugLog('ARFilter ìƒì„±ì í˜¸ì¶œë¨');
      }

      async init() {
        try {
          debugLog('ì´ˆê¸°í™” ì‹œì‘');
          
          // 1. ì¹´ë©”ë¼ ê¶Œí•œ ì²´í¬
          debugLog('ì¹´ë©”ë¼ ê¶Œí•œ ì²´í¬ ì¤‘...');
          await this.checkCameraPermission();
          
          // 2. ì¹´ë©”ë¼ ìŠ¤íŠ¸ë¦¼ íšë“
          debugLog('ì¹´ë©”ë¼ ìŠ¤íŠ¸ë¦¼ íšë“ ì¤‘...');
          await this.setupCamera();
          
          // 3. Three.js ì„¤ì •
          debugLog('Three.js ì„¤ì • ì¤‘...');
          this.setupThreeJS();
          
          // 4. í•„í„° ìƒì„±
          debugLog('í•„í„° ìƒì„± ì¤‘...');
          this.createFilter();
          
          // 5. ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
          debugLog('ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘');
          this.startAnimation();
          
          debugLog('ì´ˆê¸°í™” ì™„ë£Œ!');
          return true;
          
        } catch (error) {
          debugLog(`ì´ˆê¸°í™” ì‹¤íŒ¨: ${error.message}`);
          throw error;
        }
      }

      async checkCameraPermission() {
        try {
          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error('ë¸Œë¼ìš°ì €ê°€ ì¹´ë©”ë¼ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤');
          }
          
          const result = await navigator.permissions.query({ name: 'camera' });
          debugLog(`ì¹´ë©”ë¼ ê¶Œí•œ ìƒíƒœ: ${result.state}`);
          
          return true;
        } catch (error) {
          debugLog(`ê¶Œí•œ ì²´í¬ ì‹¤íŒ¨: ${error.message}`);
          // ê¶Œí•œ ì²´í¬ê°€ ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰
          return true;
        }
      }

      async setupCamera() {
        try {
          updateStatus('ì¹´ë©”ë¼ì— ì ‘ê·¼í•˜ëŠ” ì¤‘...');
          
          const constraints = {
            video: {
              facingMode: this.facingMode,
              width: { ideal: 640, max: 1280 },
              height: { ideal: 480, max: 720 }
            },
            audio: false
          };
          
          debugLog(`ì¹´ë©”ë¼ ì œì•½ì¡°ê±´: ${JSON.stringify(constraints)}`);
          
          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          debugLog(`ìŠ¤íŠ¸ë¦¼ íšë“ ì„±ê³µ: ${stream.id}`);
          
          // ë¹„ë””ì˜¤ ì—˜ë¦¬ë¨¼íŠ¸ ìƒì„±
          this.video = document.createElement('video');
          this.video.id = 'video';
          this.video.srcObject = stream;
          this.video.autoplay = true;
          this.video.playsInline = true;
          this.video.muted = true;
          
          // ì»¨í…Œì´ë„ˆì— ì¶”ê°€
          const container = document.getElementById('ar-container');
          container.appendChild(this.video);
          
          // ë¹„ë””ì˜¤ ë¡œë“œ ëŒ€ê¸°
          return new Promise((resolve, reject) => {
            this.video.addEventListener('loadedmetadata', () => {
              debugLog(`ë¹„ë””ì˜¤ ë©”íƒ€ë°ì´í„° ë¡œë“œë¨: ${this.video.videoWidth}x${this.video.videoHeight}`);
              updateStatus('ì¹´ë©”ë¼ ì—°ê²°ë¨');
              resolve();
            });
            
            this.video.addEventListener('error', (e) => {
              debugLog(`ë¹„ë””ì˜¤ ì˜¤ë¥˜: ${e.message}`);
              reject(new Error('ë¹„ë””ì˜¤ ë¡œë“œ ì‹¤íŒ¨'));
            });
            
            // 5ì´ˆ íƒ€ì„ì•„ì›ƒ
            setTimeout(() => {
              reject(new Error('ë¹„ë””ì˜¤ ë¡œë“œ íƒ€ì„ì•„ì›ƒ'));
            }, 5000);
          });
          
        } catch (error) {
          debugLog(`ì¹´ë©”ë¼ ì„¤ì • ì‹¤íŒ¨: ${error.message}`);
          updateStatus(`ì¹´ë©”ë¼ ì˜¤ë¥˜: ${error.message}`);
          throw error;
        }
      }

      setupThreeJS() {
        try {
          updateStatus('3D ì—”ì§„ ì´ˆê¸°í™” ì¤‘...');
          
          // ì”¬ ìƒì„±
          this.scene = new THREE.Scene();
          debugLog('Three.js ì”¬ ìƒì„±ë¨');
          
          // ì¹´ë©”ë¼ ìƒì„±
          this.camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
          );
          this.camera.position.z = 1;
          debugLog('Three.js ì¹´ë©”ë¼ ìƒì„±ë¨');
          
          // ë Œë”ëŸ¬ ìƒì„±
          this.renderer = new THREE.WebGLRenderer({ 
            alpha: true,
            antialias: true
          });
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.renderer.domElement.id = 'canvas';
          
          // ì»¨í…Œì´ë„ˆì— ì¶”ê°€
          const container = document.getElementById('ar-container');
          container.appendChild(this.renderer.domElement);
          debugLog('Three.js ë Œë”ëŸ¬ ìƒì„±ë¨');
          
          // ì¡°ëª… ì¶”ê°€
          const light = new THREE.DirectionalLight(0xffffff, 1);
          light.position.set(0, 1, 1);
          this.scene.add(light);
          
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
          this.scene.add(ambientLight);
          debugLog('ì¡°ëª… ì¶”ê°€ë¨');
          
          // ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸
          window.addEventListener('resize', () => this.onWindowResize());
          
          updateStatus('3D ì—”ì§„ ì´ˆê¸°í™” ì™„ë£Œ');
          
        } catch (error) {
          debugLog(`Three.js ì„¤ì • ì‹¤íŒ¨: ${error.message}`);
          throw error;
        }
      }

      createFilter() {
        try {
          // í•„í„° ê·¸ë£¹ ìƒì„±
          this.filterGroup = new THREE.Group();
          this.filters = [];
          
          // 1. ì›í˜• ë‹¬ê³ ë‚˜ (ê¸°ë³¸)
          const circularDalgona = this.createCircularDalgona();
          this.filters.push(circularDalgona);
          
          // 2. ë³„ ëª¨ì–‘ ë‹¬ê³ ë‚˜
          const starDalgona = this.createStarDalgona();
          this.filters.push(starDalgona);
          
          // 3. í•˜íŠ¸ ëª¨ì–‘ ë‹¬ê³ ë‚˜
          const heartDalgona = this.createHeartDalgona();
          this.filters.push(heartDalgona);
          
          // ëª¨ë“  í•„í„°ë¥¼ ê·¸ë£¹ì— ì¶”ê°€
          this.filters.forEach((filter, index) => {
            filter.visible = index === 0; // ì²« ë²ˆì§¸ë§Œ ë³´ì´ê²Œ
            this.filterGroup.add(filter);
          });
          
          // ì”¬ì— ì¶”ê°€
          this.scene.add(this.filterGroup);
          
          debugLog('ë‹¬ê³ ë‚˜ í•„í„° ìƒì„± ì™„ë£Œ');
          updateStatus('ë‹¬ê³ ë‚˜ AR í•„í„° ì¤€ë¹„ë¨');
          
        } catch (error) {
          debugLog(`í•„í„° ìƒì„± ì‹¤íŒ¨: ${error.message}`);
          throw error;
        }
      }

      createCircularDalgona() {
        const group = new THREE.Group();
        
        // ë‹¬ê³ ë‚˜ ë² ì´ìŠ¤ (ì›í˜•)
        const dalgonaGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.03, 32);
        const dalgonaMaterial = new THREE.MeshLambertMaterial({ 
          color: 0xD2691E, // ë‹¬ê³ ë‚˜ ìƒ‰ìƒ (ê°ˆìƒ‰)
          transparent: true,
          opacity: 0.9
        });
        const dalgonaBase = new THREE.Mesh(dalgonaGeometry, dalgonaMaterial);
        dalgonaBase.position.set(0, 0.1, 0.05);
        
        // ë‹¬ê³ ë‚˜ ì•ˆì˜ ë³„ ëª¨ì–‘ (ëš«ë¦° ë¶€ë¶„)
        const starShape = this.createStarShape(0.08);
        const starGeometry = new THREE.ExtrudeGeometry(starShape, {
          depth: 0.04,
          bevelEnabled: false
        });
        const starMaterial = new THREE.MeshLambertMaterial({ 
          color: 0x8B4513,
          transparent: true,
          opacity: 0.7
        });
        const starCutout = new THREE.Mesh(starGeometry, starMaterial);
        starCutout.position.set(0, 0.1, 0.03);
        starCutout.rotation.z = Math.PI; // ë³„ ë°©í–¥ ì¡°ì •
        
        // ë‹¬ê³ ë‚˜ ê°€ì¥ìë¦¬ í•˜ì´ë¼ì´íŠ¸
        const edgeGeometry = new THREE.TorusGeometry(0.25, 0.01, 8, 32);
        const edgeMaterial = new THREE.MeshLambertMaterial({ 
          color: 0xF4A460,
          transparent: true,
          opacity: 0.8
        });
        const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
        edge.position.set(0, 0.125, 0.05);
        edge.rotation.x = Math.PI / 2;
        
        group.add(dalgonaBase, starCutout, edge);
        return group;
      }

      createStarDalgona() {
        const group = new THREE.Group();
        
        // ë³„ ëª¨ì–‘ ë‹¬ê³ ë‚˜
        const starShape = this.createStarShape(0.2);
        const starGeometry = new THREE.ExtrudeGeometry(starShape, {
          depth: 0.03,
          bevelEnabled: true,
          bevelThickness: 0.005,
          bevelSize: 0.01
        });
        const starMaterial = new THREE.MeshLambertMaterial({ 
          color: 0xD2691E,
          transparent: true,
          opacity: 0.9
        });
        const starDalgona = new THREE.Mesh(starGeometry, starMaterial);
        starDalgona.position.set(0, 0.1, 0.05);
        starDalgona.rotation.z = Math.PI;
        
        // ë³„ ì¤‘ì•™ì— ì‘ì€ í•˜íŠ¸
        const heartShape = this.createHeartShape(0.05);
        const heartGeometry = new THREE.ExtrudeGeometry(heartShape, {
          depth: 0.04,
          bevelEnabled: false
        });
        const heartMaterial = new THREE.MeshLambertMaterial({ 
          color: 0xFF69B4,
          transparent: true,
          opacity: 0.8
        });
        const heartCutout = new THREE.Mesh(heartGeometry, heartMaterial);
        heartCutout.position.set(0, 0.1, 0.03);
        
        group.add(starDalgona, heartCutout);
        return group;
      }

      createHeartDalgona() {
        const group = new THREE.Group();
        
        // í•˜íŠ¸ ëª¨ì–‘ ë‹¬ê³ ë‚˜
        const heartShape = this.createHeartShape(0.15);
        const heartGeometry = new THREE.ExtrudeGeometry(heartShape, {
          depth: 0.03,
          bevelEnabled: true,
          bevelThickness: 0.005,
          bevelSize: 0.01
        });
        const heartMaterial = new THREE.MeshLambertMaterial({ 
          color: 0xD2691E,
          transparent: true,
          opacity: 0.9
        });
        const heartDalgona = new THREE.Mesh(heartGeometry, heartMaterial);
        heartDalgona.position.set(0, 0.1, 0.05);
        
        // í•˜íŠ¸ ì¤‘ì•™ì— ì‘ì€ ì›
        const circleGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.04, 16);
        const circleMaterial = new THREE.MeshLambertMaterial({ 
          color: 0xFFD700,
          transparent: true,
          opacity: 0.8
        });
        const circleCutout = new THREE.Mesh(circleGeometry, circleMaterial);
        circleCutout.position.set(0, 0.1, 0.03);
        
        group.add(heartDalgona, circleCutout);
        return group;
      }

      createStarShape(size) {
        const starShape = new THREE.Shape();
        const outerRadius = size;
        const innerRadius = size * 0.4;
        const spikes = 5;
        
        for (let i = 0; i < spikes * 2; i++) {
          const angle = (i / (spikes * 2)) * Math.PI * 2;
          const radius = i % 2 === 0 ? outerRadius : innerRadius;
          const x = Math.cos(angle) * radius;
          const y = Math.sin(angle) * radius;
          
          if (i === 0) {
            starShape.moveTo(x, y);
          } else {
            starShape.lineTo(x, y);
          }
        }
        starShape.closePath();
        return starShape;
      }

      createHeartShape(size) {
        const heartShape = new THREE.Shape();
        const x = 0, y = 0;
        
        heartShape.moveTo(x, y + size/2);
        heartShape.bezierCurveTo(x, y + size/2, x - size/2, y, x, y - size/4);
        heartShape.bezierCurveTo(x + size/2, y, x, y + size/2, x, y + size/2);
        
        return heartShape;
      }

      startAnimation() {
        this.isRunning = true;
        this.currentFilter = 0;
        this.biteStage = 0; // ë² ì–´ë¨¹ê¸° ë‹¨ê³„
        updateStatus('ë‹¬ê³ ë‚˜ AR í•„í„° í™œì„±í™”ë¨! ì…ì„ ë²Œë ¤ë³´ì„¸ìš”');
        
        const animate = () => {
          if (!this.isRunning) return;
          
          // ë‹¬ê³ ë‚˜ ì• ë‹ˆë©”ì´ì…˜ (ì•½ê°„ì˜ í”ë“¤ë¦¼ê³¼ íšŒì „)
          const time = Date.now() * 0.001;
          if (this.filterGroup) {
            // ìì—°ìŠ¤ëŸ¬ìš´ ì–¼êµ´ ì›€ì§ì„ ì‹œë®¬ë ˆì´ì…˜
            this.filterGroup.position.x = Math.sin(time * 0.8) * 0.02;
            this.filterGroup.position.y = 0.1 + Math.cos(time * 0.6) * 0.03;
            this.filterGroup.rotation.z = Math.sin(time * 0.4) * 0.05;
            
            // ë‹¬ê³ ë‚˜ê°€ ì‚´ì§ ë¹›ë‚˜ëŠ” íš¨ê³¼
            this.filters.forEach(filter => {
              if (filter.visible) {
                filter.children.forEach(child => {
                  if (child.material && child.material.opacity) {
                    child.material.opacity = 0.85 + Math.sin(time * 2) * 0.1;
                  }
                });
              }
            });
          }
          
          this.renderer.render(this.scene, this.camera);
          requestAnimationFrame(animate);
        };
        
        animate();
        debugLog('ë‹¬ê³ ë‚˜ ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ ì‹œì‘ë¨');
      }

      switchFilter() {
        if (this.filters && this.filters.length > 0) {
          // í˜„ì¬ í•„í„° ìˆ¨ê¸°ê¸°
          this.filters[this.currentFilter].visible = false;
          
          // ë‹¤ìŒ í•„í„°ë¡œ ì „í™˜
          this.currentFilter = (this.currentFilter + 1) % this.filters.length;
          this.filters[this.currentFilter].visible = true;
          
          const filterNames = ['ì›í˜• ë‹¬ê³ ë‚˜', 'ë³„ ë‹¬ê³ ë‚˜', 'í•˜íŠ¸ ë‹¬ê³ ë‚˜'];
          debugLog(`í•„í„° ì „í™˜: ${filterNames[this.currentFilter]}`);
          updateStatus(`${filterNames[this.currentFilter]}ë¡œ ë³€ê²½ë¨!`);
        }
      }

      biteEffect() {
        if (this.filters && this.filters[this.currentFilter]) {
          const currentFilter = this.filters[this.currentFilter];
          this.biteStage = (this.biteStage + 1) % 4;
          
          switch(this.biteStage) {
            case 1:
              // ì²« ë²ˆì§¸ ë² ì–´ë¨¹ê¸° - í¬ê¸° ê°ì†Œ
              currentFilter.scale.set(0.8, 0.8, 0.8);
              updateStatus('ì•„ì‚­! ë‹¬ê³ ë‚˜ë¥¼ í•œ ì… ë² ì–´ë¨¹ì—ˆì–´ìš”');
              break;
            case 2:
              // ë‘ ë²ˆì§¸ ë² ì–´ë¨¹ê¸° - ë” ì‘ê²Œ
              currentFilter.scale.set(0.6, 0.6, 0.6);
              updateStatus('ë˜ í•œ ì…! ë‹¬ê³ ë‚˜ê°€ ì‘ì•„ì§€ê³  ìˆì–´ìš”');
              break;
            case 3:
              // ê±°ì˜ ë‹¤ ë¨¹ìŒ - ë§¤ìš° ì‘ê²Œ
              currentFilter.scale.set(0.3, 0.3, 0.3);
              updateStatus('ê±°ì˜ ë‹¤ ë¨¹ì—ˆì–´ìš”! ë‹¬ë‹¬í•œ ë‹¬ê³ ë‚˜~');
              break;
            case 0:
              // ì›ë˜ í¬ê¸°ë¡œ ë³µì›
              currentFilter.scale.set(1, 1, 1);
              updateStatus('ìƒˆë¡œìš´ ë‹¬ê³ ë‚˜ê°€ ë‚˜íƒ€ë‚¬ì–´ìš”!');
              break;
          }
          
          // ë² ì–´ë¨¹ì„ ë•Œ ì•½ê°„ì˜ íšŒì „ íš¨ê³¼
          currentFilter.rotation.z += 0.1;
          
          debugLog(`ë‹¬ê³ ë‚˜ ë² ì–´ë¨¹ê¸° ë‹¨ê³„: ${this.biteStage}`);
        }
      }

      onWindowResize() {
        if (this.camera && this.renderer) {
          this.camera.aspect = window.innerWidth / window.innerHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          debugLog('í™”ë©´ í¬ê¸° ì¡°ì •ë¨');
        }
      }

      stop() {
        this.isRunning = false;
        if (this.video && this.video.srcObject) {
          this.video.srcObject.getTracks().forEach(track => track.stop());
          debugLog('ì¹´ë©”ë¼ ìŠ¤íŠ¸ë¦¼ ì •ì§€ë¨');
        }
      }
    }

    // ë©”ì¸ ì•± ë¡œì§
    let arApp = null;

    // ë¸Œë¼ìš°ì € ì§€ì› ì²´í¬
    function checkBrowserSupport() {
      const checks = {
        webgl: !!window.WebGLRenderingContext,
        getUserMedia: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),
        https: location.protocol === 'https:' || location.hostname === 'localhost'
      };
      
      debugLog(`ë¸Œë¼ìš°ì € ì§€ì› ì²´í¬: ${JSON.stringify(checks)}`);
      
      if (!checks.webgl) {
        throw new Error('WebGLì„ ì§€ì›í•˜ì§€ ì•ŠëŠ” ë¸Œë¼ìš°ì €ì…ë‹ˆë‹¤');
      }
      
      if (!checks.getUserMedia) {
        throw new Error('ì¹´ë©”ë¼ APIë¥¼ ì§€ì›í•˜ì§€ ì•ŠëŠ” ë¸Œë¼ìš°ì €ì…ë‹ˆë‹¤');
      }
      
      if (!checks.https) {
        throw new Error('HTTPS í™˜ê²½ì—ì„œë§Œ ì¹´ë©”ë¼ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤');
      }
      
      return true;
    }

    // ì‹œì‘ ë²„íŠ¼ ì´ë²¤íŠ¸
    document.getElementById('start').addEventListener('click', async () => {
      const startBtn = document.getElementById('start');
      const ui = document.getElementById('ui');
      const controls = document.getElementById('controls');
      
      try {
        debugLog('ì‹œì‘ ë²„íŠ¼ í´ë¦­ë¨');
        
        // ë²„íŠ¼ ë¹„í™œì„±í™”
        startBtn.disabled = true;
        startBtn.textContent = 'ì´ˆê¸°í™” ì¤‘...';
        
        // ë¸Œë¼ìš°ì € ì§€ì› ì²´í¬
        checkBrowserSupport();
        
        // AR ì•± ìƒì„± ë° ì´ˆê¸°í™”
        arApp = new SimpleARFilter();
        await arApp.init();
        
        // UI ìˆ¨ê¸°ê¸° ë° ì»¨íŠ¸ë¡¤ í‘œì‹œ
        ui.style.display = 'none';
        controls.style.display = 'flex';
        
        debugLog('ì•± ì‹œì‘ ì™„ë£Œ');
        
      } catch (error) {
        debugLog(`ì•± ì‹œì‘ ì‹¤íŒ¨: ${error.message}`);
        updateStatus(`ì˜¤ë¥˜: ${error.message}`);
        
        // ë²„íŠ¼ ë‹¤ì‹œ í™œì„±í™”
        startBtn.disabled = false;
        startBtn.textContent = 'ë‹¤ì‹œ ì‹œë„';
      }
    });

    // ì»¨íŠ¸ë¡¤ ë²„íŠ¼ ì´ë²¤íŠ¸ë“¤
    document.getElementById('toggle-filter').addEventListener('click', () => {
      debugLog('ë‹¬ê³ ë‚˜ ëª¨ì–‘ ë³€ê²½ ë²„íŠ¼ í´ë¦­ë¨');
      if (arApp && arApp.switchFilter) {
        arApp.switchFilter();
      }
    });

    document.getElementById('switch-camera').addEventListener('click', () => {
      debugLog('ì¹´ë©”ë¼ ì „í™˜ ë²„íŠ¼ í´ë¦­ë¨');
      // ì¹´ë©”ë¼ ì „í™˜ ë¡œì§
    });

    document.getElementById('bite-effect').addEventListener('click', () => {
      debugLog('ë‹¬ê³ ë‚˜ ë² ì–´ë¨¹ê¸° ë²„íŠ¼ í´ë¦­ë¨');
      if (arApp && arApp.biteEffect) {
        arApp.biteEffect();
      }
    });

    // í˜ì´ì§€ ì–¸ë¡œë“œ ì‹œ ì •ë¦¬
    window.addEventListener('beforeunload', () => {
      if (arApp) {
        arApp.stop();
      }
    });

    // ì´ˆê¸° ë””ë²„ê·¸ ì •ë³´
    debugLog('ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œë¨');
    debugLog(`User Agent: ${navigator.userAgent}`);
    debugLog(`Protocol: ${location.protocol}`);
    debugLog(`Hostname: ${location.hostname}`);
  </script>
</body>
</html>
